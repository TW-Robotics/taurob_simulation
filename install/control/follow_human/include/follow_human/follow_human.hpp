/*!
 *  @brief     Human platooning package of the UAS Technikum Wien.
 *  @details   This is the baseclass of the human platooning package.
 *  @author    Georg Novotny
 *  @author    UAS Technikum Vienna
 *  @version   1.0
 *  @date      2019
 *  @pre       First launch the corresponding launchfiles.
 *  @bug       PID Controller currently not working
 *  @copyright GNU Public License.
 */
#ifndef FOLLOW_HUMAN_CONTROL_H
#define FOLLOW_HUMAN_CONTROL_H

#include <ros/ros.h>
#include <darknet_ros_msgs/BoundingBoxes.h> // Yolonet
#include <sensor_msgs/LaserScan.h>
#include <sensor_msgs/Image.h>
#include <geometry_msgs/Twist.h>
#include <cv_bridge/cv_bridge.h>
#include <std_msgs/Float64.h>

// Dynamic Reconfigure //
#include <dynamic_reconfigure/server.h>
#include "follow_human/follow_human_mainConfig.h"


//OPENCV
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/core/core.hpp>
#include <opencv2/imgproc/imgproc.hpp>

class follow_human
{
public:
  follow_human();

private:
  ros::NodeHandle n;
  ros::Subscriber sub_yolo;
  ros::Subscriber sub_lidar;
  ros::Subscriber sub_lidar_rear;
  ros::Subscriber sub_img;
  ros::Subscriber sub_pid;
  ros::Publisher pub_cmd_vel;
  ros::Publisher pub_state_pid;
  ros::Publisher pub_setpoint_pid;


  // Dynamic Reconfigure //
  dynamic_reconfigure::Server<follow_human_cfg::follow_human_mainConfig> server;
  dynamic_reconfigure::Server<follow_human_cfg::follow_human_mainConfig>::CallbackType f;


  //---Variables for sub_yolo---//
  // Imagestream Variablen //
  int image_width, image_height;
  std::string image_topic;
  cv::Mat image;
  int bbox_width, bbox_height;
  int human_pos_x, human_pos_y;

  //---Variables for sub_laser---//
  std::vector< std::vector<float> > ranges, ranges_rear;
  float min_range_lidar;
  bool flag_lidar;


  //---Control Variables //
  geometry_msgs::Twist velocity;
  // PID Variables //
  std_msgs::Float64 setpoint, state, rot_vel;
  bool use_pid;
  // P Controller only //
  double kp, kp_lin;

  //-Config variables-//
  int setpoint_height;
  float min_probability, speed_faktor;


  //-------------//
  //--Functions--//
  // ROS //
  /*!
   * @brief Updates the config params of the explorer node
   * @param <config> autogenerated class by dynamic_reconfigure from ./cfg/explorer.cfg File
   * @param <> indicates which params have been updated (all params of one level are updated simultaneously); not used
   */
  void callback_reconf(follow_human_cfg::follow_human_mainConfig &config, uint32_t);

  /*!
   * @brief Publishes the setpoint (0.0) and the current state (image_width/2 - human_pos_x) 
   *        to the ROS PID
   */
  void pub_pid(void);

  /*!
   * @brief Calculates the linear and angular velocity based on the gains defined in the config.yaml file
   */
  void pub_p(void);

  /*!
   * @brief Callback function that is used to detect the following people and determine the 
   *        related bounding box size
   * @param <bboxes> BoundingBox message of the darknet_ros_msgs package
   */
  void callback_yolo(const darknet_ros_msgs::BoundingBoxes &bboxes);

  /*!
   * @brief Callback function to process the laser data of the front mounted LIDAR 
   *        to detect obstacles and stop bevore them. Only execute when going 
   *        forward.
   * @param <scan> Laserscan message of the front LIDAR
   */
  void callback_lidar(const sensor_msgs::LaserScan &scan);


  /*!
   * @brief Callback function to process the laser data of the rear mounted LIDAR 
   *        to detect obstacles and stop bevore them. Only executed when going 
   *        backward.
   * @param <scan> Laserscan message of the rear LIDAR
   */
  void callback_lidar_rear(const sensor_msgs::LaserScan &scan);

  /*!
   * @brief Callback of the corresponding image stream to the callback_yolo.
   *        Only used to determine the image width and height.
   *        Subscriber is shutdown after this.
   * @param <msg> Pointer to the current image of the stream.
   */
  void callback_img(const sensor_msgs::ImageConstPtr& msg);

  /*!
   * @brief Callback of the PID Controller. Used to generate the angular
   *        velocity based on the control effort of the PID algorithm. Linear 
   *        velocity is calculated using follow_human::get_lin_vel(void).
   * @param <msg> Control effort calculated by the PID controller
   * @bug Currently only returns MAX and MIN values
   * @todo Fix bug
   */
  void callback_pid(const std_msgs::Float64 &msg);



  // Helper Functions //
  /*!
   * @brief Calculates the linear velocity based on the height of the surrounding BBox of the detected human
   *        The current BBox height is used to compute a linear gain by normailzation. BBox height
   *        is between 430 (top speed) and 800 (0 speed) give 1 -> 0 linear velocity.
   * @return <lin_vel> [float] Returns the calculated linear velocity ranging from 0 to 1
   */
  float get_lin_vel(void);
};


#endif
